Automated testing workflows
Test suite architecture: Design complete testing frameworks that include unit tests, integration tests, and end-to-end testing scenarios for complex features.
Test automation pipelines: Generate test configuration files and CI/CD integration that automatically runs appropriate test suites based on code changes.
Quality gates: Create automated quality checks that ensure code meets standards before progression through the development pipeline.
Performance testing: Generate performance benchmarks and load testing scenarios to validate system behavior under various conditions.

Deployment
Configuration file generation: Help create deployment configuration files for various environments.
Deployment script assistance: Suggest commands or scripts for common deployment tasks.
Documentation updates: Assist in updating deployment documentation to reflect recent changes.

Testing & quality assurance
Test data generation: Create realistic test data sets, saving time on manual data creation.
Edge case identification: Suggest test scenarios that cover edge cases, improving the robustness of tests.

Design & development
Design pattern implementation: Suggest appropriate design patterns based on the problem context, promoting best practices.
Code optimization: Offer more efficient code alternatives, helping developers write performant code from the start.

Requirement analysis
Rapid prototyping: Quickly generate code snippets based on high-level descriptions, allowing for faster proof-of-concept development.
User story implementation: Transform user stories into initial function or class definitions, providing a starting point for development.
API design: Suggest API structures based on described functionality, helping to flesh out system architectures.

Maintenance & support
Code refactoring: Suggest improvements to existing code, helping to keep the codebase modern and efficient.
Documentation updates: Assist in keeping code comments and documentation in sync with changes.
Legacy code understanding: Help developers understand and work with unfamiliar or legacy code by providing explanations and modern equivalents.
Bug fix suggestions: Propose potential fixes for reported issues based on error messages and surrounding code.